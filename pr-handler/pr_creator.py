"""
Pull request creator for automated bug fixes.
"""

from typing import Dict, Any, List, Optional
import subprocess
import json


class PRCreator:
    """
    Create pull requests for bug fixes.
    """
    
    def __init__(self, repo_path: str, base_branch: str = 'main'):
        """
        Initialize the PR creator.
        
        Args:
            repo_path: Path to the repository
            base_branch: Base branch for pull requests
        """
        self.repo_path = repo_path
        self.base_branch = base_branch
    
    def create_branch(self, branch_name: str) -> Dict[str, Any]:
        """
        Create a new branch for bug fixes.
        
        Args:
            branch_name: Name of the branch to create
        
        Returns:
            Result dictionary
        """
        try:
            # Check if branch already exists
            result = subprocess.run(
                ['git', 'rev-parse', '--verify', branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                return {
                    'success': False,
                    'message': f'Branch {branch_name} already exists'
                }
            
            # Create new branch
            result = subprocess.run(
                ['git', 'checkout', '-b', branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            return {
                'success': result.returncode == 0,
                'branch': branch_name,
                'message': result.stdout if result.returncode == 0 else result.stderr
            }
        
        except Exception as e:
            return {
                'success': False,
                'message': f'Error creating branch: {str(e)}'
            }
    
    def commit_changes(self, message: str, files: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Commit changes to the current branch.
        
        Args:
            message: Commit message
            files: List of files to commit (None for all)
        
        Returns:
            Result dictionary
        """
        try:
            # Add files
            if files:
                for file in files:
                    subprocess.run(
                        ['git', 'add', file],
                        cwd=self.repo_path,
                        check=True
                    )
            else:
                subprocess.run(
                    ['git', 'add', '-A'],
                    cwd=self.repo_path,
                    check=True
                )
            
            # Commit
            result = subprocess.run(
                ['git', 'commit', '-m', message],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            return {
                'success': result.returncode == 0,
                'message': result.stdout if result.returncode == 0 else result.stderr
            }
        
        except Exception as e:
            return {
                'success': False,
                'message': f'Error committing changes: {str(e)}'
            }
    
    def push_branch(self, branch_name: str, remote: str = 'origin') -> Dict[str, Any]:
        """
        Push branch to remote repository.
        
        Args:
            branch_name: Name of the branch to push
            remote: Remote name
        
        Returns:
            Result dictionary
        """
        try:
            result = subprocess.run(
                ['git', 'push', '-u', remote, branch_name],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            
            return {
                'success': result.returncode == 0,
                'message': result.stdout if result.returncode == 0 else result.stderr
            }
        
        except Exception as e:
            return {
                'success': False,
                'message': f'Error pushing branch: {str(e)}'
            }
    
    def generate_pr_description(
        self,
        fixes: List[Dict[str, Any]],
        scan_results: List[Dict[str, Any]]
    ) -> str:
        """
        Generate a pull request description from fixes and scan results.
        
        Args:
            fixes: List of applied fixes
            scan_results: Original scan results
        
        Returns:
            PR description as markdown
        """
        description_parts = [
            "# Automated Bug Fixes",
            "",
            "This PR contains automated bug fixes generated by Bug-Fixing-AI-Assistant.",
            "",
            "## Summary",
            f"- Total issues found: {len(scan_results)}",
            f"- Fixes applied: {len(fixes)}",
            "",
            "## Fixed Issues",
            ""
        ]
        
        for idx, fix in enumerate(fixes, 1):
            issue = fix.get('issue', {})
            description_parts.extend([
                f"### {idx}. {issue.get('type', 'Unknown')}",
                f"- **File**: {issue.get('file', 'N/A')}",
                f"- **Line**: {issue.get('line', 'N/A')}",
                f"- **Severity**: {issue.get('severity', 'N/A')}",
                f"- **Fix**: {fix.get('description', 'N/A')}",
                ""
            ])
        
        if len(fixes) < len(scan_results):
            description_parts.extend([
                "## Remaining Issues",
                f"{len(scan_results) - len(fixes)} issues require manual review.",
                ""
            ])
        
        description_parts.extend([
            "## Validation",
            "- [x] Syntax validation passed",
            "- [ ] Tests passed (requires manual verification)",
            "- [ ] Code review required",
            ""
        ])
        
        return "\n".join(description_parts)
